
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>standardize documentation</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-12-27"><meta name="DC.source" content="standardize_documentation.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1><tt>standardize</tt> documentation</h1><!--introduction--><p><tt>standardize</tt> removes the mean of a variable and scales it such that its standard deviation is 1. This operation is sometimes known as "centering and scaling".</p><p><a href="CDT_Contents.html">Back to Climate Data Tools Contents</a>.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">Example 1: 1D time series</a></li><li><a href="#6">Example 2: 1D time series with a trend</a></li><li><a href="#10">Example 3:</a></li><li><a href="#13">Author Info</a></li></ul></div><h2 id="1">Syntax</h2><pre>Xs = standardize(X)
Xs = standardize(...,dim)
Xs = standardize(...,nanflag)
Xs = standardize(...,'weighting',w)
[Xs,mu] = standardize(...)</pre><h2 id="2">Description</h2><p><tt>Xs = standardize(X)</tt> subtracts the mean of <tt>X</tt> from <tt>X</tt>, then divides by the standard deviation of <tt>X</tt>.</p><p><tt>Xs = standardize(...,dim)</tt> specifies a dimension along which to operate. Standardization is along the first nonsingleton dimension by default.</p><p><tt>Xs = standardize(...,nanflag)</tt> specifies whether to include or omit <tt>NaN</tt> values from the calculation for any of the previous syntaxes. <tt>standardize(X,'includenan')</tt> includes all NaN values in the calculation while <tt>standardize(X,'omitnan')</tt> ignores them. Default behavior is <tt>'includenan'</tt>.</p><p><tt>Xs = standardize(...,'weighting',w)</tt> specifies a weighting scheme <tt>w</tt> for the calculation of the standard deviation. When w = 0 (default), S is normalized by N-1. When <tt>w</tt> = 1, S is normalized by the number of observations, N. <tt>w</tt> also can be a weight vector containing nonnegative elements. In this case, the length of <tt>w</tt> must equal the length of the dimension over which std is operating.</p><p><tt>[Xs,mu] = standardize(...)</tt> returns mu mean and standard deviation of X. If <tt>X</tt> is a vector, <tt>mu(1)</tt> is the mean of <tt>X</tt> and <tt>mu(2)</tt> is the standard deviation of <tt>X</tt>. If <tt>X</tt> is multidimensional, the mean is the first entry in the direction of operation and std is the second entry. In other words, if <tt>X</tt> is three dimensional and is standardized alnog the third dimension, <tt>mu(:,:,1)</tt> is the mean and <tt>mu(:,:,2)</tt> is the standard deviation of <tt>X</tt>.</p><h2 id="3">Example 1: 1D time series</h2><p>Here's a time series:</p><pre class="codeinput">x = 1:700;
y = 15*sind(x)+3*randn(size(x))+300;

plot(x,y)
</pre><img vspace="5" hspace="5" src="standardize_documentation_01.png" alt=""> <p>In the figure above, you can see that the mean of <tt>y</tt> is about 300 and the standard deviation is about 10. Standardize <tt>y</tt> like this:</p><pre class="codeinput">ys = standardize(y);

plot(x,ys)
</pre><img vspace="5" hspace="5" src="standardize_documentation_02.png" alt=""> <p>Now the signal oscillates around 0 and its standard deviation is 1.</p><h2 id="6">Example 2: 1D time series with a trend</h2><p>What if your time series has a trend in it? Like this:</p><pre class="codeinput">x = 1:1080;
y = 15*sind(x)+3*randn(size(x))+300 +x/5;

plot(x,y)
</pre><img vspace="5" hspace="5" src="standardize_documentation_03.png" alt=""> <p>It's important to note that standardizing and then detrending does not produce the same result as detrending and then standardizing. Here's the difference:</p><pre class="codeinput"><span class="comment">% standardize y:</span>
ys = standardize(y);

<span class="comment">% detrend the standardized y:</span>
ysd = detrend(ys);

plot(x,ysd)
legend(<span class="string">'standardized then detrended'</span>)
</pre><img vspace="5" hspace="5" src="standardize_documentation_04.png" alt=""> <pre class="codeinput">yd = detrend(y);

yds = standardize(yd);

hold <span class="string">on</span>
plot(x,yds)
legend(<span class="string">'standardized then detrended'</span>,<span class="keyword">...</span>
   <span class="string">'detrended then standardized'</span>)
</pre><img vspace="5" hspace="5" src="standardize_documentation_05.png" alt=""> <p>The end results, <tt>ysd</tt> and <tt>yds</tt> both have mean values of 0, but the standard deviation of <tt>ysd</tt> is smaller than 1 because it was detrended after standardization.</p><h2 id="10">Example 3:</h2><p>Consider this sample sea surface temperature dataset that is 60x55x802 in size. Begin by plotting the mean and standard deviation of the raw sst dataset:</p><pre class="codeinput">load <span class="string">pacific_sst</span>


figure
subplot(1,2,1)
imagescn(lon,lat,mean(sst,3))
cmocean <span class="string">thermal</span>
cb(1) = colorbar(<span class="string">'location'</span>,<span class="string">'northoutside'</span>);
xlabel(cb(1),<span class="string">'mean sst (\circC)'</span>)

subplot(1,2,2)
imagescn(lon,lat,std(sst,[],3))
cmocean <span class="string">amp</span>
cb(2) = colorbar(<span class="string">'location'</span>,<span class="string">'northoutside'</span>);
xlabel(cb(2),<span class="string">'\sigma sst (\circC)'</span>)
</pre><img vspace="5" hspace="5" src="standardize_documentation_06.png" alt=""> <p>The maps above show about what we'd expect: On average it's warm close to the equator and cooler toward the poles. The North American Great Lakes, which are quite chilly on average, have the greatest sst variability because they freeze in winter but warm up nicely in the summer.</p><p>If you want to center and scale this SST dataset,</p><pre class="codeinput"><span class="comment">% Standardize sst along dimension 3:</span>
sst_s = standardize(sst,3);

figure
subplot(1,2,1)
imagescn(lon,lat,mean(sst_s,3))
cmocean <span class="string">thermal</span>
cb(1) = colorbar(<span class="string">'location'</span>,<span class="string">'northoutside'</span>);
xlabel(cb(1),<span class="string">'mean sst (\circC)'</span>)

subplot(1,2,2)
imagescn(lon,lat,std(sst_s,[],3))
cmocean <span class="string">amp</span>
cb(2) = colorbar(<span class="string">'location'</span>,<span class="string">'northoutside'</span>);
xlabel(cb(2),<span class="string">'\sigma sst (\circC)'</span>)
</pre><img vspace="5" hspace="5" src="standardize_documentation_07.png" alt=""> <p>The plot above on the left shows that the mean of the sst after it has been centered and scaled is just numerical noise. That's a characteristic noise pattern that should always encourage you to check the scientific notation on the colorbar axes.</p><p>And on the right, the standard deviation is 1 everywhere. That's because that's exactly what we set it to be with <tt>standardize</tt>.</p><h2 id="13">Author Info</h2><p>This function is part of the <a href="http://www.github.com/chadagreene/CDT">Climate Data Toolbox for Matlab</a>. The function and supporting documentation were written by Chad A. Greene of the University of Texas at Austin.</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% |standardize| documentation
% |standardize| removes the mean of a variable and scales it such that its
% standard deviation is 1. This operation is sometimes known as "centering
% and scaling". 
% 
% <CDT_Contents.html Back to Climate Data Tools Contents>.
%% Syntax
% 
%  Xs = standardize(X) 
%  Xs = standardize(...,dim)
%  Xs = standardize(...,nanflag) 
%  Xs = standardize(...,'weighting',w)
%  [Xs,mu] = standardize(...)
%  
%% Description 
% 
% |Xs = standardize(X)| subtracts the mean of |X| from |X|, then divides by the 
% standard deviation of |X|. 
% 
% |Xs = standardize(...,dim)| specifies a dimension along which to operate.
% Standardization is along the first nonsingleton dimension by default.
% 
% |Xs = standardize(...,nanflag)| specifies whether to include or omit |NaN| values from the 
% calculation for any of the previous syntaxes. |standardize(X,'includenan')| includes 
% all NaN values in the calculation while |standardize(X,'omitnan')| ignores
% them. Default behavior is |'includenan'|. 
% 
% |Xs = standardize(...,'weighting',w)| specifies a weighting scheme |w| for the  
% calculation of the standard deviation. When w = 0 (default), S is normalized by N-1.
% When |w| = 1, S is normalized by the number of observations, N. |w| also can be a
% weight vector containing nonnegative elements. In this case, the length
% of |w| must equal the length of the dimension over which std is operating. 
% 
% |[Xs,mu] = standardize(...)| returns mu mean and standard deviation of X.
% If |X| is a vector, |mu(1)| is the mean of |X| and |mu(2)| is the standard
% deviation of |X|. If |X| is multidimensional, the mean is the first entry
% in the direction of operation and std is the second entry. In other
% words, if |X| is three dimensional and is standardized alnog the third
% dimension, |mu(:,:,1)| is the mean and |mu(:,:,2)| is the standard deviation
% of |X|. 
% 
%% Example 1: 1D time series
% Here's a time series: 

x = 1:700; 
y = 15*sind(x)+3*randn(size(x))+300; 

plot(x,y) 

%% 
% In the figure above, you can see that the mean of |y| is about 300 and the 
% standard deviation is about 10. Standardize |y| like this: 

ys = standardize(y); 

plot(x,ys)

%% 
% Now the signal oscillates around 0 and its standard deviation is 1. 

%% Example 2: 1D time series with a trend
% What if your time series has a trend in it? Like this: 

x = 1:1080; 
y = 15*sind(x)+3*randn(size(x))+300 +x/5; 

plot(x,y)

%% 
% It's important to note that standardizing and then detrending does not
% produce the same result as detrending and then standardizing. Here's the
% difference: 

% standardize y: 
ys = standardize(y); 

% detrend the standardized y: 
ysd = detrend(ys); 

plot(x,ysd) 
legend('standardized then detrended')

%% 

yd = detrend(y); 

yds = standardize(yd); 

hold on
plot(x,yds) 
legend('standardized then detrended',...
   'detrended then standardized')

%% 
% The end results, |ysd| and |yds| both have mean values of 0, but the
% standard deviation of |ysd| is smaller than 1 because it was detrended 
% after standardization. 

%% Example 3: 
% Consider this sample sea surface temperature dataset that is 60x55x802 in
% size. Begin by plotting the mean and standard deviation of the
% raw sst dataset: 

load pacific_sst 


figure
subplot(1,2,1) 
imagescn(lon,lat,mean(sst,3))
cmocean thermal
cb(1) = colorbar('location','northoutside'); 
xlabel(cb(1),'mean sst (\circC)')

subplot(1,2,2) 
imagescn(lon,lat,std(sst,[],3))
cmocean amp
cb(2) = colorbar('location','northoutside'); 
xlabel(cb(2),'\sigma sst (\circC)')

%% 
% The maps above show about what we'd expect: On average it's warm close
% to the equator and cooler toward the poles. The North American Great
% Lakes, which are quite chilly on average, have the greatest sst
% variability because they freeze in winter but warm up nicely in the
% summer. 
% 
% If you want to center and scale this SST dataset, 

% Standardize sst along dimension 3:
sst_s = standardize(sst,3); 

figure
subplot(1,2,1) 
imagescn(lon,lat,mean(sst_s,3))
cmocean thermal
cb(1) = colorbar('location','northoutside'); 
xlabel(cb(1),'mean sst (\circC)')

subplot(1,2,2) 
imagescn(lon,lat,std(sst_s,[],3))
cmocean amp
cb(2) = colorbar('location','northoutside'); 
xlabel(cb(2),'\sigma sst (\circC)')

%% 
% The plot above on the left shows that the mean of the sst after it has been 
% centered and scaled is just numerical noise. That's a characteristic
% noise pattern that should always encourage you to check the scientific 
% notation on the colorbar axes. 
% 
% And on the right, the standard deviation is 1 everywhere. That's because
% that's exactly what we set it to be with |standardize|.

%% Author Info
% This function is part of the <http://www.github.com/chadagreene/CDT Climate Data Toolbox for Matlab>.
% The function and supporting documentation were written by Chad A. Greene
% of the University of Texas at Austin. 
##### SOURCE END #####
--></body></html>