
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>eof documentation</title><meta name="generator" content="MATLAB 9.7"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-02-18"><meta name="DC.source" content="eof_documentation.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1><tt>eof</tt> documentation</h1><!--introduction--><p>The <tt>eof</tt> function gives eigenmode maps of variability and corresponding principal component time series for spatiotemporal data analysis. This function is designed specifically for 3D matricies of data such as sea surface temperatures where dimensions 1 and 2 are spatial dimensions (e.g., lat and lon; lon and lat; x and y, etc.), and the third dimension represents different slices or snapshots of data in time.</p><p>See also: <a href="reof_documentation.html"><tt>reof</tt></a>.</p><p><a href="CDT_Contents.html">Back to Climate Data Tools Contents</a>.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">A simple example</a></li><li><a href="#6">TUTORIAL: From raw climate reanalysis data to ENSO, PDO, etc.</a></li><li><a href="#8">Average sea surface temperature</a></li><li><a href="#9">Global warming</a></li><li><a href="#10">Remove the global warming signal</a></li><li><a href="#11">Remove seasonal cycles</a></li><li><a href="#14">Calculate EOFs</a></li><li><a href="#16">Optional scaling of Principal Components and EOF maps</a></li><li><a href="#17">El Ni&ntilde;o Southern Oscillation (ENSO) time series</a></li><li><a href="#19">ENSO in the frequency domain</a></li><li><a href="#21">Maps of variability</a></li><li><a href="#23">Make a movie of SST variability from EOFs</a></li><li><a href="#28">How I got the sample data</a></li><li><a href="#29">References</a></li><li><a href="#30">Author Info</a></li></ul></div><h2 id="1">Syntax</h2><pre>eof_maps = eof(A)
eof_maps = eof(A,n)
eof_maps = eof(...,'mask',mask)
[eof_maps,pc,expvar] = eof(...)</pre><h2 id="2">Description</h2><p><tt>eof_maps = eof(A)</tt> calculates all modes of variability in <tt>A</tt>, where <tt>A</tt> is a 3D matrix whose first two dimensions are spatial, the third dimension is temporal, and data are assumed to be equally spaced in time. Output <tt>eof_maps</tt> have the same dimensions as <tt>A</tt>, where each map along the third dimension represents a mode of variability order of importance.</p><p><tt>eof_maps = eof(A,n)</tt> only calculates the first <tt>n</tt> modes of variability. For large datasets, it's computationally faster to only calculate the number of modes you'll need. If <tt>n</tt> is not specified, all EOFs are calculated (one for each time slice).</p><p><tt>eof_maps = eof(...,'mask',mask)</tt> only performs EOF analysis on the grid cells represented by ones in a logical <tt>mask</tt> whose dimensions correspond to dimensions 1 and 2 of <tt>A</tt>. This option is provided to prevent solving for things that don't need to be solved, or to let you do analysis on one region separately from another. By default, any grid cells in <tt>A</tt> which contain <i>any</i> NaNs are masked out.</p><p><tt>[eof_maps,pc,expvar] = eof(...)</tt> returns the principal component time series <tt>pc</tt> whose rows each represent a different mode from 1 to <tt>n</tt> and columns correspond to time steps. For example, <tt>pc(1,:)</tt> is the time series of the first (dominant) mode of varibility.  The third output <tt>expvar</tt> is the percent of variance explained by each mode. See the note below on interpreting <tt>expvar</tt>.</p><h2 id="3">A simple example</h2><p>Here's a quick example of how to use the <tt>eof</tt> function. Proper EOF analysis requires detrending and deseasoning the data before calculating EOFs, and those steps are described in the tutorial below, but for now let's just pretend this sample dataset is ready to be analyzed.  Load the sample data, then calculate the first EOF.</p><p>Here I'm plotting the first EOF map using the <a href="cmocean_documentation.html"><tt>cmocean</tt></a> <i>delta</i> colormap (Thyng et al., 2016) with the <tt>'pivot'</tt> argument to ensure it's centered about zero.</p><pre class="codeinput"><span class="comment">% Load sample data:</span>
load <span class="string">pacific_sst.mat</span>

<span class="comment">% Calculate the first EOF of sea surface temperatures and its</span>
<span class="comment">% principal component time series:</span>
[eofmap,pc] = eof(sst,1);

<span class="comment">% Plot the first EOF map:</span>
imagescn(lon,lat,eofmap);
axis <span class="string">xy</span> <span class="string">image</span> <span class="string">off</span>

<span class="comment">% Optional: Use a cmocean colormap:</span>
cmocean(<span class="string">'delta'</span>,<span class="string">'pivot'</span>,0)
</pre><img vspace="5" hspace="5" src="eof_documentation_01.png" alt=""> <p>That's the first EOF of the SST dataset, but since we haven't removed the seasonal cycle, the first EOF primarily represents seasonal variability.  As evidence that the pattern above is associated with the seasonal cycle, take a look at the corresponding principal component time series.</p><pre class="codeinput">figure
anomaly(t,pc)
axis <span class="string">tight</span>
xlim([datenum(<span class="string">'jan 1, 1990'</span>) datenum(<span class="string">'jan 1, 1995'</span>)])
datetick(<span class="string">'x'</span>,<span class="string">'keeplimits'</span>)
</pre><img vspace="5" hspace="5" src="eof_documentation_02.png" alt=""> <p>That looks pretty seasonal to me.</p><h2 id="6">TUTORIAL: From raw climate reanalysis data to ENSO, PDO, etc.</h2><p>CDT comes with a sample dataset called <tt>pacific_sst.mat</tt>, which is a downsampled subset of the Hadley Centre's HadISST sea surface temperature dataset.  At the end of this tutorial there's a section which describes how I imported the raw NetCDF data into Matlab and the process I used to subset it.  If you follow along with this tutorial from top to bottom you should be able to apply EOF analysis to any similar dataset.</p><p>If you haven't already loaded the sample dataset, load it now and get an idea of its contents by checking the names and sizes of the variables:</p><pre class="codeinput">load <span class="string">pacific_sst.mat</span>
whos
</pre><pre class="codeoutput">  Name          Size                   Bytes  Class     Attributes

  eofmap       60x55                   26400  double              
  lat          60x1                      480  double              
  lon          55x1                      440  double              
  pc            1x802                   6416  double              
  sst          60x55x802            21172800  double              
  t           802x1                     6416  double              

</pre><p>So we have a 3D <tt>sst</tt> matrix whose dimensions correspond to lat x lon x time.  What time range, and what are the time steps, you ask?  Let's take a look at the first and last date, and the average time step:</p><pre class="codeinput">datestr(t([1 end]))
mean(diff(t))
</pre><pre class="codeoutput">ans =
  2&times;20 char array
    '15-Jan-1950 12:00:00'
    '15-Oct-2016 12:00:00'
ans =
         30.44
</pre><h2 id="8">Average sea surface temperature</h2><p>Okay, so this is monthly data, centered on about the 15th of each month, from 1950 to 2016. To get a sense of what the dataset looks like, display the mean temperature over that time.  I'm using <a href="imagescn_documentation.html"><tt>imagescn</tt></a>, which automatically makes NaN values transparent, but you can use <tt>imagesc</tt>, <tt>pcolor</tt>, or any equivalent mapping toolbox functions if you prefer. I'm also using the <a href="cmocean_documentation.html"><tt>cmocean</tt></a> <i>thermal</i> colormap (Thyng et al., 2016):</p><pre class="codeinput">figure
imagescn(lon,lat,mean(sst,3));
axis <span class="string">xy</span> <span class="string">off</span>
cb = colorbar;
ylabel(cb,<span class="string">' mean temperature {\circ}C '</span>)
cmocean <span class="string">thermal</span>
</pre><img vspace="5" hspace="5" src="eof_documentation_03.png" alt=""> <h2 id="9">Global warming</h2><p>Is global warming real?  The <a href="trend_documentation.html"><tt>trend</tt></a> function lets us easily get the linear trend of temperature from 1950 to 2016. Be sure to multiply the trend by 10*365.25 to convert from degrees per day to degrees per decade:</p><pre class="codeinput">imagescn(lon,lat,10*365.25*trend(sst,t,3))
axis <span class="string">xy</span> <span class="string">off</span>
cb = colorbar;
ylabel(cb,<span class="string">' temperature trend {\circ}C per decade '</span>)
cmocean(<span class="string">'balance'</span>,<span class="string">'pivot'</span>)
</pre><img vspace="5" hspace="5" src="eof_documentation_04.png" alt=""> <h2 id="10">Remove the global warming signal</h2><p>The global warming trend is interesting, but EOF analysis is all about variablity, not long-term trends, so we must remove the trend by <a href="detrend3_documentation"><tt>detrend3</tt></a>:</p><pre class="codeinput">sst = detrend3(sst,t);
</pre><h2 id="11">Remove seasonal cycles</h2><p>If you plot the temperature trend again, you'll see that it's all been reduced to zero, with perhaps a few eps of numerical noise. Now that's an SST dataset that even Anthony Watts would approve of.</p><p>We have now detrended the SST dataset (which also removed the mean), but it still contains quite a bit of seasonal variability that should be removed before EOF analysis because we're not interested in seasonal signals.</p><pre class="codeinput">sst = deseason(sst,t);
</pre><p>So now our <tt>sst</tt> dataset has been detrended, the mean removed, and the seasonal cycle removed. All that's left in <tt>sst</tt> are the anomalies--things that change, but are not long-term trends or short-term annual cycles.  Here's the remaining variance of our <tt>sst</tt> anomaly dataset:</p><pre class="codeinput">figure
imagescn(lon,lat,var(sst,[],3));
axis <span class="string">xy</span> <span class="string">off</span>
colorbar
title(<span class="string">'variance of temperature'</span>)
colormap(jet) <span class="comment">% jet is inexcusable except when recreating old plots</span>
caxis([0 1])
</pre><img vspace="5" hspace="5" src="eof_documentation_05.png" alt=""> <p>The map above lines up quite well with Figure 2a of <a href="http://dx.doi.org/10.1175/2011JCLI3941.1">Messie and Chavez (2011)</a>, which tells us we're on the right track.</p><h2 id="14">Calculate EOFs</h2><p>EOF analysis lets us understand not only where things vary, but how often, and what regions tend to vary together or out of phase with each other.  With our detrended, deseasoned <tt>sst</tt> dataset, EOF analysis is this simple with the <tt>eof</tt> function:</p><pre class="codeinput">[eof_maps,pc,expv] = eof(sst);

<span class="comment">% Plot the first mode:</span>
figure
imagesc(lon,lat,eof_maps(:,:,1))
axis <span class="string">xy</span> <span class="string">image</span>
cmocean(<span class="string">'curl'</span>,<span class="string">'pivot'</span>)
title <span class="string">'The first EOF mode!'</span>
</pre><img vspace="5" hspace="5" src="eof_documentation_06.png" alt=""> <p>Eigenvector analysis has a funny behavior that can produce EOF maps which are positive or negative, and the solutions can come up different every time using the same exact inputs. Positive and negative solutions are equally valid -- think of the modes of vibration of a drum head where some regions of the drum head go up while other regions go down, and then they switch -- and likewise the eigenvalue solutions of SST variability might be positive or negative.  The only thing that matters is that when we reconstruct a time series from an EOF solution, we multiply each EOF map by its corresponding principal component (<tt>pc</tt>).</p><p>The <tt>eof</tt> function is written to produce consistent results each time you run it with the same data, but don't worry if the sign of a solution does not match the sign of someone else's results if they used a different program to calculate EOFs--that just means their program picked the opposite-sign solution, and that's perfectly fine.</p><p>Just as EOF maps can have positive or negative solutions and both are equally valid, there's some flexibility in how the magnitudes of EOF maps are displayed. You can multiply the magnitude of an EOF map by any value you want, just as long as you divide the corresponding principal component time series by the same value.  Let's take a look at the time series of the first three modes of variability, plotting with <a href="subsubplot_documentation.html"><tt>subsubplot</tt></a>:</p><pre class="codeinput">figure
subsubplot(3,1,1)
plot(t,pc(1,:))
box <span class="string">off</span>
axis <span class="string">tight</span>
ylabel <span class="string">'pc1'</span>
title <span class="string">'The first three principal components'</span>

subsubplot(3,1,2)
plot(t,pc(2,:))
box <span class="string">off</span>
axis <span class="string">tight</span>
set(gca,<span class="string">'yaxislocation'</span>,<span class="string">'right'</span>)
ylabel <span class="string">'pc2'</span>

subsubplot(3,1,3)
plot(t,pc(3,:))
box <span class="string">off</span>
axis <span class="string">tight</span>
ylabel <span class="string">'pc3'</span>
datetick(<span class="string">'x'</span>,<span class="string">'keeplimits'</span>)
</pre><img vspace="5" hspace="5" src="eof_documentation_07.png" alt=""> <h2 id="16">Optional scaling of Principal Components and EOF maps</h2><p>Those principal component time series are fine just the way they are, but some folks prefer to scale each time series to span a desired range. Looking at Figure 5 of <a href="http://dx.doi.org/10.1175/2011JCLI3941.1">Messie and Chavez (2011)</a>, it seems they chose to scale each principal component time series such that it spans the range -1 to 1.  Let's do the same thing, divide each principal component time series by its maximum value and don't forget to multiply the corresponding EOF map by the same value:</p><pre class="codeinput"><span class="keyword">for</span> k = 1:size(pc,1)

   <span class="comment">% Find the the maximum value in the time series of each principal component:</span>
   maxval = max(abs(pc(k,:)));

   <span class="comment">% Divide the time series by its maximum value:</span>
   pc(k,:) = pc(k,:)/maxval;

   <span class="comment">% Multiply the corresponding EOF map:</span>
   eof_maps(:,:,k) = eof_maps(:,:,k)*maxval;
<span class="keyword">end</span>
</pre><h2 id="17">El Ni&ntilde;o Southern Oscillation (ENSO) time series</h2><p>The first mode of detrended, deseasoned SSTs is assoiciated with ENSO. We can plot the time series again as a simple line plot, but anomaly plots are often filled in. Let's use <a href="anomaly_documentation.html"><tt>anomaly</tt></a> to plot the first mode, and multiply by -1 to match the sign of Figure 5 of <a href="http://dx.doi.org/10.1175/2011JCLI3941.1">Messie and Chavez (2011)</a>.</p><pre class="codeinput">figure(<span class="string">'pos'</span>,[100 100 600 250])
anomaly(t,-pc(1,:),<span class="string">'topcolor'</span>,rgb(<span class="string">'bubblegum'</span>),<span class="keyword">...</span>
   <span class="string">'bottomcolor'</span>,rgb(<span class="string">'periwinkle blue'</span>)) <span class="comment">% First principal component is enso</span>
box <span class="string">off</span>
axis <span class="string">tight</span>
datetick(<span class="string">'x'</span>,<span class="string">'keeplimits'</span>)
text([724316 729713 736290],[.95 .99 .81],<span class="string">'El Nino'</span>,<span class="string">'horiz'</span>,<span class="string">'center'</span>)
</pre><img vspace="5" hspace="5" src="eof_documentation_08.png" alt=""> <p>Sure enough, some of the <a href="https://en.wikipedia.org/wiki/El_Ni%C3%B1o">strongest El Nino events on record</a> took place in 1982-1983, 1997-1998, and 2014-2016. For more ways to investigate ENSO, check out the <a href="enso_documentation.html"><tt>enso</tt></a> function.</p><h2 id="19">ENSO in the frequency domain</h2><p>Sometimes we hear that El Nino has a characteristic frequency of once every five years, or five to seven years, or sometimes you hear it's every two to seven years.  It's hard to see that in the time series, so we plot the first principal component in the frequency domain with <a href="plotpsd_documentation.html"><tt>plotpsd</tt></a>, specifying a sampling frequency of 12 samples per year, plotted on a log x axis, with x values in units of lambda (years) rather than frequency:</p><pre class="codeinput">figure
plotpsd(pc(1,:),12,<span class="string">'logx'</span>,<span class="string">'lambda'</span>)
xlabel <span class="string">'periodicity (years)'</span>
set(gca,<span class="string">'xtick'</span>,[1:7 33])
</pre><img vspace="5" hspace="5" src="eof_documentation_09.png" alt=""> <p>As you can see, the ENSO signal does not have a sharply defined resonance frequency, but there's energy in that whole two-to-seven year range. I also labeled the 33 year periodicity because that's Nyquist for this particular dataset--any energy with a longer period than Nyquist (or anywhere near it) should probably be considered junk.</p><h2 id="21">Maps of variability</h2><p>EOFs aren't just about time series--they're about spatial patterns of variability through time. Each mode has a characteristic pattern of variability just like the different modes of vibration of a drum head. At any given time, the different modes can be summed to create a total picture of temperature anomalies at that time. The <i>orthogonal</i> part of Empirical Orthogonal Function means each of the modes tend to do their own thing, independent of the other modes.  Let's look at the first six modes by recreating Figure 4 of <a href="http://dx.doi.org/10.1175/2011JCLI3941.1">Messie and Chavez (2011)</a> .  I'm multiplying some of the modes by negative one because I want to match their signs, and remember, we're allowed to do that.</p><pre class="codeinput">s = [-1 1 -1 1 -1 1]; <span class="comment">% (sign multiplier to match Messie and Chavez 2011)</span>

figure(<span class="string">'pos'</span>,[100 100 500 700])
<span class="keyword">for</span> k = 1:6
   subplot(3,2,k)
   imagescn(lon,lat,eof_maps(:,:,k)*s(k));
   axis <span class="string">xy</span> <span class="string">off</span>
   title([<span class="string">'Mode '</span>,num2str(k),<span class="string">' ('</span>,num2str(expv(k),<span class="string">'%0.1f'</span>),<span class="string">'%)'</span>])
   caxis([-2 2])
<span class="keyword">end</span>

colormap <span class="string">jet</span>
</pre><img vspace="5" hspace="5" src="eof_documentation_10.png" alt=""> <p>The percent variance explained by each mode does not match Messie and Chavez because we're using a much shorter time series than they did and we're also using a spatial subset of the world data.  Nonetheless, patterns generally agree.</p><p>The <tt>jet</tt> colormap is not exactly the same one used by Messie and Chavez, which explains why some of the patterns above may look slightly different from Messie and Chavez. But since we're talking about colormaps, rainbows are actually quite bad at representing numerical data (<a href="https://doi.org/10.5670/oceanog.2016.66">Thyng et al, 2016</a>). It's also a shame for science that we can't exactly replicate the plot without knowing exactly what colors were used in the published version, but I digress...</p><p>Given that these maps represent anomalies, they should be represented by a divergent colormap that gives equal weight to each side of zero. Let's set the colormaps of all the subplots in this figure to something a little more balanced:</p><pre class="codeinput">colormap(gcf,cmocean(<span class="string">'balance'</span>))
</pre><img vspace="5" hspace="5" src="eof_documentation_11.png" alt=""> <h2 id="23">Make a movie of SST variability from EOFs</h2><p>At any given time, a snapshot of sea surface temperature anomalies associated with ENSO can be obtained by plotting the map of mode 1 shown above, multiplied by its corresponding principal component (the vector <tt>pc(1,:)</tt>) at that time.  Similarly, you can get a picture of worldwide sea surface temperature anomalies at a given time by summing all the EOF maps, each multiplied by their corresponding principal component at that time.  In this way we can build a more-and-more complete movie of SST anomalies as we include more and more more modes of variability.</p><p>For example, a map of SST anomalies associated with the first three modes of variability, for a specified time, can be obtained by summing the eof maps of each of those modes, multiplied by their corresponding pc values for that time. You can do the summing manually, say, for the 1990's like this:</p><pre>% Indices of start and end dates for the movie:
startind = find(t&gt;=datenum('jan 1, 1990'),1,'first');
endind = find(t&lt;=datenum('dec 31, 1999'),1,'last');</pre><pre>% A map of SST anomalies from first three modes at start:
map = eof_maps(:,:,1)*pc(1,startind) + ... % Mode 1, Jan 1990
      eof_maps(:,:,2)*pc(2,startind) + ... % Mode 2, Jan 1990
      eof_maps(:,:,3)*pc(3,startind);      % Mode 3, Jan 1990</pre><p>However, that's more complicated than necessary, because the <a href="reof_documentation.html"><tt>reof</tt></a> function is designed to do the summing for us. Make an sst anomaly time series for the first three modes like this:</p><pre class="codeinput">sst_f = reof(eof_maps,pc,1:3);
</pre><p>Now plot the January 1990 map as the first frame in a movie:</p><pre>ind_1990s = 481:3:600; % (every third value to cut down on gif size)</pre><pre>figure
h = imagescn(sst_f(:,:,ind_1990s(1)));
caxis([-2 2])
cmocean balance
cb = colorbar;
ylabel(cb,'temperature anomaly (modes 1-3)')
title(datestr(t(ind_1990s(1)),'yyyy'))</pre><pre>gif('SSTs_1990s.gif','frame',gcf) % writes the first frame</pre><pre>for k = 2:length(ind_1990s)
   h.CData = sst_f(:,:,ind_1990s(k));
   title(datestr(t(ind_1990s(k)),'yyyy'))
   gif % adds this frame to the gif
end</pre><p><img vspace="5" hspace="5" src="SSTs_1990s.gif" alt=""> </p><p>The first thing you probably notice is that the 1990s SST anomaly time series is dominated by ENSO, and check out that 1997-1998 signal!  No wonder it was such a hot topic in the <a href="https://www.nbc.com/saturday-night-live/video/el-nino/2861308">news</a> that year. Nonetheless, it's important to remember that the movie above is not a complete reconstruction of the SST anomalies, but rather only the first three modes, which together account for</p><pre class="codeinput">sum(expv(1:3))
</pre><pre class="codeoutput">ans =
         51.88
</pre><p>...just over half of the total variance of the SST dataset. To reconstruct the absolute temperature field rather than just anomalies from the first three modes, you'd need to include all the EOF maps, and you'd also have to add back in the mean SST map, the trend, and the seasonal cycle.</p><h2 id="28">How I got the sample data</h2><p>The example dataset shown above comes from the Hadley Center HadISST, found <a href="http://www.metoffice.gov.uk/hadobs/hadisst/data/download.html">here</a> (Rayner et al., 2003) which in full exceeds 200 MB.  If you'd like to perform the the same kind of analysis on a different region of the world, you can download the HadISST_sst.nc dataset and import it into Matlab like this.  Downsampling or subsetting the dataset are up to you:</p><pre>% Load the full SST dataset:
lat = double(ncread('HadISST_sst.nc','latitude'));
lon = double(ncread('HadISST_sst.nc','longitude'));
t = double(ncread('HadISST_sst.nc','time')+datenum(1870,1,0));
sst = ncread('HadISST_sst.nc','sst');</pre><pre>% To quarter the size of the sample dataset, I crudely downsample to every other grid point:
sst = sst(1:2:end,1:2:end,:);
lat = lat(1:2:end);
lon = lon(1:2:end);</pre><pre>% To further reduce size, I clipped to a range of lats and lons and kept only post-1950 data:
rows = lon&lt;-70;
lon = lon(rows);
cols = lat&gt;=-60 &amp; lat&lt;=60;
lat = lat(cols);
times = t&gt;=datenum('jan 1, 1950');
t = t(times);
sst = sst(rows,cols,times);
sst(sst&lt;-50) = NaN;</pre><pre>% I find it easier to rearrange as lat x lon x time:
sst = permute(sst,[2 1 3]);</pre><pre>% Save the sample data:
save('PacOcean.mat','lat','lon','t','sst')</pre><h2 id="29">References</h2><p>Messi&eacute;, Monique, and Francisco Chavez. "Global modes of sea surface temperature variability in relation to regional climate indices." Journal of Climate 24.16 (2011): 4314-4331. <a href="http://dx.doi.org/10.1175/2011JCLI3941.1">doi:10.1175/2011JCLI3941.1</a>.</p><p>Rayner, N. A., Parker, D. E., Horton, E. B., Folland, C. K., Alexander, L. V., Rowell, D. P., Kent, E. C., Kaplan, A. (2003). Global analyses of sea surface temperature, sea ice, and night marine air temperature since the late nineteenth century. J. Geophys. Res.Vol. 108, No. D14, 4407 <a href="http://dx.doi.org/10.1029/2002JD002670">doi:10.1029/2002JD002670</a>.</p><p>Thyng, K.M., C.A. Greene, R.D. Hetland, H.M. Zimmerle, and S.F. DiMarco. 2016. True colors of oceanography: Guidelines for effective and accurate colormap selection. Oceanography 29(3):9-13, <a href="http://dx.doi.org/10.5670/oceanog.2016.66">doi:10.5670/oceanog.2016.66</a>.</p><h2 id="30">Author Info</h2><p>The <tt>eof</tt> function was written by <a href="http://www.chadagreene.com">Chad A. Greene</a> of the University of Texas Institute for Geophysics (UTIG) in January 2017, but leans heavily on Guillame MAZE's <tt>caleof</tt> function from his <a href="https://www.mathworks.com/matlabcentral/fileexchange/17915">PCATool</a> contribution. This tutorial was written by Chad Greene with help from <a href="https://www.kaustubh.info/">Kaustubh Thirumalai</a>.</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% |eof| documentation
% The |eof| function gives eigenmode maps of variability and corresponding principal component
% time series for spatiotemporal data analysis. This function is designed specifically for 3D matricies
% of data such as sea surface temperatures where dimensions 1 and 2 are spatial dimensions 
% (e.g., lat and lon; lon and lat; x and y, etc.), and the third dimension represents different 
% slices or snapshots of data in time.  
% 
% See also: <reof_documentation.html |reof|>.
% 
% <CDT_Contents.html Back to Climate Data Tools Contents>.
%% Syntax
% 
%  eof_maps = eof(A) 
%  eof_maps = eof(A,n) 
%  eof_maps = eof(...,'mask',mask) 
%  [eof_maps,pc,expvar] = eof(...)
% 
%% Description 
% 
% |eof_maps = eof(A)| calculates all modes of variability in |A|, where |A| is a 3D matrix whose
% first two dimensions are spatial, the third dimension is temporal, and data are assumed to be 
% equally spaced in time. Output |eof_maps| have the same dimensions as |A|, where each map along 
% the third dimension represents a mode of variability order of importance. 
% 
% |eof_maps = eof(A,n)| only calculates the first |n| modes of variability. For large datasets, 
% it's computationally faster to only calculate the number of modes you'll need. If |n| is not
% specified, all EOFs are calculated (one for each time slice). 
% 
% |eof_maps = eof(...,'mask',mask)| only performs EOF analysis on the grid cells represented by 
% ones in a logical |mask| whose dimensions correspond to dimensions 1 and 2 of |A|. This option
% is provided to prevent solving for things that don't need to be solved, or to let you do analysis
% on one region separately from another. By default, any grid cells in |A| which contain _any_ NaNs 
% are masked out.  
% 
% |[eof_maps,pc,expvar] = eof(...)| returns the principal component time series |pc| whose rows
% each represent a different mode from 1 to |n| and columns correspond to time steps. For example, 
% |pc(1,:)| is the time series of the first (dominant) mode of varibility.  The third output |expvar| 
% is the percent of variance explained by each mode. See the note below on interpreting |expvar|. 
% 
%% A simple example
% Here's a quick example of how to use the |eof| function. Proper EOF analysis requires detrending
% and deseasoning the data before calculating EOFs, and those steps are described in the tutorial 
% below, but for now let's just pretend this sample dataset is ready to be analyzed.  Load
% the sample data, then calculate the first EOF.  
% 
% Here I'm plotting the first EOF map using the <cmocean_documentation.html |cmocean|> _delta_ colormap 
% (Thyng et al., 2016) with the |'pivot'| argument to ensure it's centered about zero. 

% Load sample data: 
load pacific_sst.mat

% Calculate the first EOF of sea surface temperatures and its 
% principal component time series: 
[eofmap,pc] = eof(sst,1); 

% Plot the first EOF map: 
imagescn(lon,lat,eofmap); 
axis xy image off

% Optional: Use a cmocean colormap:
cmocean('delta','pivot',0)

%% 
% That's the first EOF of the SST dataset, but since we haven't removed the seasonal cycle, 
% the first EOF primarily represents seasonal variability.  As evidence that the pattern
% above is associated with the seasonal cycle, take a look at the corresponding principal component 
% time series.
 
figure
anomaly(t,pc) 
axis tight
xlim([datenum('jan 1, 1990') datenum('jan 1, 1995')])
datetick('x','keeplimits')

%% 
% That looks pretty seasonal to me. 

%% TUTORIAL: From raw climate reanalysis data to ENSO, PDO, etc.
% CDT comes with a sample dataset called |pacific_sst.mat|, which is a downsampled subset 
% of the Hadley Centre's HadISST sea surface temperature dataset.  At the end of this tutorial there's 
% a section which describes how I imported the raw NetCDF data into Matlab and the process I used 
% to subset it.  If you follow along with this tutorial from top to bottom you should be able to 
% apply EOF analysis to any similar dataset.  
% 
% If you haven't already loaded the sample dataset, load it now and get an idea of its contents
% by checking the names and sizes of the variables: 

load pacific_sst.mat
whos

%% 
% So we have a 3D |sst| matrix whose dimensions correspond to lat x lon x time.  What time range, 
% and what are the time steps, you ask?  Let's take a look at the first and last date, and the
% average time step: 

datestr(t([1 end]))
mean(diff(t))

%% Average sea surface temperature
% Okay, so this is monthly data, centered on about the 15th of each month, from 1950 to 2016. To get
% a sense of what the dataset looks like, display the mean temperature over that time.  I'm using
% <imagescn_documentation.html |imagescn|>, which automatically makes NaN values transparent, but
% you can use |imagesc|, |pcolor|, or any equivalent mapping toolbox functions if you prefer. I'm
% also using the <cmocean_documentation.html |cmocean|> _thermal_ colormap (Thyng et al., 2016): 

figure
imagescn(lon,lat,mean(sst,3)); 
axis xy off
cb = colorbar; 
ylabel(cb,' mean temperature {\circ}C ') 
cmocean thermal

%% Global warming
% Is global warming real?  The <trend_documentation.html |trend|> function
% lets us easily get the linear trend of temperature from 1950 to 2016. Be sure to multiply the trend by 10*365.25
% to convert from degrees per day to degrees per decade: 

imagescn(lon,lat,10*365.25*trend(sst,t,3))
axis xy off
cb = colorbar; 
ylabel(cb,' temperature trend {\circ}C per decade ') 
cmocean('balance','pivot') 

%% Remove the global warming signal
% The global warming trend is interesting, but EOF analysis is all about variablity, not long-term trends, so
% we must remove the trend by <detrend3_documentation |detrend3|>: 

sst = detrend3(sst,t); 

%% Remove seasonal cycles 
% If you plot the temperature trend again, you'll see that it's all been reduced to zero, with perhaps a few eps 
% of numerical noise. Now that's an SST dataset that even Anthony Watts would approve of.  
% 
% We have now detrended the SST dataset (which also removed the mean), but it still contains quite a bit of seasonal 
% variability that should be removed before EOF analysis because we're not interested in seasonal signals. 

sst = deseason(sst,t); 

%% 
% So now our |sst| dataset has been detrended, the mean removed, and the seasonal cycle removed. 
% All that's left in |sst| are the anomaliesREPLACE_WITH_DASH_DASHthings that change, but are not long-term trends
% or short-term annual cycles.  Here's the remaining variance of our |sst| anomaly dataset: 

figure
imagescn(lon,lat,var(sst,[],3)); 
axis xy off
colorbar
title('variance of temperature') 
colormap(jet) % jet is inexcusable except when recreating old plots
caxis([0 1])

%% 
% The map above lines up quite well with Figure 2a of <http://dx.doi.org/10.1175/2011JCLI3941.1 Messie and Chavez (2011)>, 
% which tells us we're on the right track. 

%% Calculate EOFs
% EOF analysis lets us understand not only where things vary, but how often, and what regions tend to vary together
% or out of phase with each other.  With our detrended, deseasoned |sst| dataset, EOF analysis is
% this simple with the |eof| function: 

[eof_maps,pc,expv] = eof(sst);

% Plot the first mode: 
figure
imagesc(lon,lat,eof_maps(:,:,1))
axis xy image
cmocean('curl','pivot')
title 'The first EOF mode!'

%% 
% Eigenvector analysis has a funny behavior that can produce EOF maps which are positive 
% or negative, and the solutions can come up different every time using the same exact inputs. 
% Positive and negative solutions are equally valid REPLACE_WITH_DASH_DASH think of the modes of vibration of a 
% drum head where some regions of the drum head go up while other regions go down, and then 
% they switch REPLACE_WITH_DASH_DASH and likewise the eigenvalue solutions of SST variability might be positive
% or negative.  The only thing that matters is that when we reconstruct a time series from 
% an EOF solution, we multiply each EOF map by its corresponding principal component (|pc|). 
% 
% The |eof| function is written to produce consistent results each time you run it with 
% the same data, but don't worry if the sign of a solution does not match the sign of someone 
% else's results if they used a different program to calculate EOFsREPLACE_WITH_DASH_DASHthat just means their program
% picked the opposite-sign solution, and that's perfectly fine.  
% 
% Just as EOF maps can have positive or negative solutions and both are equally valid, there's
% some flexibility in how the magnitudes of EOF maps are displayed. You can multiply the magnitude
% of an EOF map by any value you want, just as long as you divide the corresponding principal component
% time series by the same value.  Let's take a look at the time series of the first three modes
% of variability, plotting with <subsubplot_documentation.html |subsubplot|>:

figure
subsubplot(3,1,1)
plot(t,pc(1,:))
box off 
axis tight
ylabel 'pc1'
title 'The first three principal components'

subsubplot(3,1,2)
plot(t,pc(2,:))
box off 
axis tight
set(gca,'yaxislocation','right')
ylabel 'pc2'

subsubplot(3,1,3)
plot(t,pc(3,:))
box off 
axis tight
ylabel 'pc3'
datetick('x','keeplimits')

%% Optional scaling of Principal Components and EOF maps
% Those principal component time series are fine just the way they are, but some folks prefer
% to scale each time series to span a desired range. Looking at Figure 5 of <http://dx.doi.org/10.1175/2011JCLI3941.1 Messie and Chavez (2011)>, 
% it seems they chose to scale each principal component time series such that it spans the
% range -1 to 1.  Let's do the same thing, divide each principal component time series by its
% maximum value and don't forget to multiply the corresponding EOF map by the same value: 

for k = 1:size(pc,1) 
   
   % Find the the maximum value in the time series of each principal component: 
   maxval = max(abs(pc(k,:))); 
   
   % Divide the time series by its maximum value: 
   pc(k,:) = pc(k,:)/maxval; 
   
   % Multiply the corresponding EOF map: 
   eof_maps(:,:,k) = eof_maps(:,:,k)*maxval; 
end

%% El Niño Southern Oscillation (ENSO) time series
% The first mode of detrended, deseasoned SSTs is assoiciated with ENSO. We can plot the 
% time series again as a simple line plot, but anomaly plots are often filled in. Let's use 
% <anomaly_documentation.html |anomaly|> to plot the first mode, and multiply by -1 to match 
% the sign of Figure 5 of <http://dx.doi.org/10.1175/2011JCLI3941.1 Messie and Chavez (2011)>. 

figure('pos',[100 100 600 250]) 
anomaly(t,-pc(1,:),'topcolor',rgb('bubblegum'),...
   'bottomcolor',rgb('periwinkle blue')) % First principal component is enso
box off
axis tight
datetick('x','keeplimits') 
text([724316 729713 736290],[.95 .99 .81],'El Nino','horiz','center')

%%
% Sure enough, some of the <https://en.wikipedia.org/wiki/El_Ni%C3%B1o strongest El Nino events on record>
% took place in 1982-1983, 1997-1998, and 2014-2016. For more ways to investigate ENSO, 
% check out the <enso_documentation.html |enso|> function. 

%% ENSO in the frequency domain
% Sometimes we hear that El Nino has a characteristic frequency of once every five years, or five to seven years, 
% or sometimes you hear it's every two to seven years.  It's hard to see that in the time series, so we plot the first principal component in 
% the frequency domain with <plotpsd_documentation.html |plotpsd|>, 
% specifying a sampling frequency of 12 samples per year, plotted on a log x axis, with x values in 
% units of lambda (years) rather than frequency: 

figure
plotpsd(pc(1,:),12,'logx','lambda')
xlabel 'periodicity (years)'
set(gca,'xtick',[1:7 33])

%% 
% As you can see, the ENSO signal does not have a sharply defined resonance frequency, 
% but there's energy in that whole two-to-seven year range. I also labeled the 33 year
% periodicity because that's Nyquist for this particular datasetREPLACE_WITH_DASH_DASHany energy with a longer
% period than Nyquist (or anywhere near it) should probably be considered junk. 

%% Maps of variability
% EOFs aren't just about time seriesREPLACE_WITH_DASH_DASHthey're about spatial patterns of variability through time. Each mode
% has a characteristic pattern of variability just like the different modes of vibration of a drum head. At 
% any given time, the different modes can be summed to create a total picture of temperature anomalies at 
% that time. The _orthogonal_ part of Empirical Orthogonal Function means each of the modes tend to do their
% own thing, independent of the other modes.  Let's look at the first six modes by recreating Figure 4 of 
% <http://dx.doi.org/10.1175/2011JCLI3941.1 Messie and Chavez (2011)> .  I'm multiplying some of the modes
% by negative one because I want to match their signs, and remember, we're allowed to do that. 

s = [-1 1 -1 1 -1 1]; % (sign multiplier to match Messie and Chavez 2011)

figure('pos',[100 100 500 700])
for k = 1:6
   subplot(3,2,k) 
   imagescn(lon,lat,eof_maps(:,:,k)*s(k)); 
   axis xy off
   title(['Mode ',num2str(k),' (',num2str(expv(k),'%0.1f'),'%)'])
   caxis([-2 2]) 
end

colormap jet 

%% 
% The percent variance explained by each mode does not match Messie and Chavez because we're using a much shorter
% time series than they did and we're also using a spatial subset of the world data.  Nonetheless, 
% patterns generally agree.  
% 
% The |jet| colormap is not exactly the same one used by Messie and Chavez, which explains why some of the patterns
% above may look slightly different from Messie and Chavez. But since we're talking about colormaps, rainbows are 
% actually quite bad at representing numerical data (<https://doi.org/10.5670/oceanog.2016.66 Thyng et al, 2016>). 
% It's also a shame for science that we can't exactly replicate the plot without knowing exactly what colors were used
% in the published version, but I digress... 
% 
% Given that these maps represent anomalies, they should be represented by a divergent colormap that gives equal 
% weight to each side of zero. Let's set the colormaps of all the subplots in this figure to something a little
% more balanced: 

colormap(gcf,cmocean('balance'))

%% Make a movie of SST variability from EOFs
% At any given time, a snapshot of sea surface temperature anomalies associated with 
% ENSO can be obtained by plotting the map of mode 1 shown above, multiplied by its
% corresponding principal component (the vector |pc(1,:)|) at that time.  Similarly, 
% you can get a picture of worldwide sea surface temperature anomalies at a given time
% by summing all the EOF maps, each multiplied by their corresponding principal component
% at that time.  In this way we can build a more-and-more complete movie of SST anomalies
% as we include more and more more modes of variability. 
% 
% For example, a map of SST anomalies associated with the first three modes of variability, 
% for a specified time, can be obtained by summing the eof maps of each of those 
% modes, multiplied by their corresponding pc values for that time. You can do
% the summing manually, say, for the 1990's like this: 
% 
%  % Indices of start and end dates for the movie: 
%  startind = find(t>=datenum('jan 1, 1990'),1,'first'); 
%  endind = find(t<=datenum('dec 31, 1999'),1,'last'); 
%  
%  % A map of SST anomalies from first three modes at start:
%  map = eof_maps(:,:,1)*pc(1,startind) + ... % Mode 1, Jan 1990
%        eof_maps(:,:,2)*pc(2,startind) + ... % Mode 2, Jan 1990
%        eof_maps(:,:,3)*pc(3,startind);      % Mode 3, Jan 1990
%  
%% 
% However, that's more complicated than necessary, because the <reof_documentation.html 
% |reof|> function is designed to do the summing for us. Make an sst anomaly 
% time series for the first three modes like this: 

sst_f = reof(eof_maps,pc,1:3); 

%% 
% Now plot the January 1990 map as the first frame in a movie: 
% 
%  ind_1990s = 481:3:600; % (every third value to cut down on gif size)
%  
%  figure
%  h = imagescn(sst_f(:,:,ind_1990s(1))); 
%  caxis([-2 2]) 
%  cmocean balance
%  cb = colorbar; 
%  ylabel(cb,'temperature anomaly (modes 1-3)')
%  title(datestr(t(ind_1990s(1)),'yyyy')) 
%  
%  
%  gif('SSTs_1990s.gif','frame',gcf) % writes the first frame
%  
%  for k = 2:length(ind_1990s)
%     h.CData = sst_f(:,:,ind_1990s(k)); 
%     title(datestr(t(ind_1990s(k)),'yyyy')) 
%     gif % adds this frame to the gif 
%  end
%  
% <<SSTs_1990s.gif>>
% 
%% 
% The first thing you probably notice is that the 1990s SST anomaly time series is dominated by ENSO, 
% and check out that 1997-1998 signal!  No wonder it was such a hot topic in the <https://www.nbc.com/saturday-night-live/video/el-nino/2861308
% news> that year. Nonetheless, it's important to remember that the movie above is not a complete reconstruction of 
% the SST anomalies, but rather only the first three modes, which together account for 

sum(expv(1:3))

%% 
% ...just over half of the total variance of the SST dataset. To reconstruct the absolute temperature field rather than 
% just anomalies from the first three modes, you'd need to include all the EOF maps, and you'd also 
% have to add back in the mean SST map, the trend, and the seasonal cycle.  

%% How I got the sample data
% The example dataset shown above comes from the Hadley Center HadISST, found <http://www.metoffice.gov.uk/hadobs/hadisst/data/download.html here>
% (Rayner et al., 2003) which in full exceeds 200 MB.  If you'd like to perform the the same kind of analysis on a different region of the world,
% you can download the HadISST_sst.nc dataset and import it into Matlab like this.  Downsampling or subsetting the dataset are up to you: 
%  
%  % Load the full SST dataset: 
%  lat = double(ncread('HadISST_sst.nc','latitude')); 
%  lon = double(ncread('HadISST_sst.nc','longitude')); 
%  t = double(ncread('HadISST_sst.nc','time')+datenum(1870,1,0)); 
%  sst = ncread('HadISST_sst.nc','sst'); 
%  
%  % To quarter the size of the sample dataset, I crudely downsample to every other grid point: 
%  sst = sst(1:2:end,1:2:end,:); 
%  lat = lat(1:2:end); 
%  lon = lon(1:2:end); 
%  
%  % To further reduce size, I clipped to a range of lats and lons and kept only post-1950 data: 
%  rows = lon<-70; 
%  lon = lon(rows); 
%  cols = lat>=-60 & lat<=60; 
%  lat = lat(cols); 
%  times = t>=datenum('jan 1, 1950'); 
%  t = t(times); 
%  sst = sst(rows,cols,times); 
%  sst(sst<-50) = NaN; 
%  
%  % I find it easier to rearrange as lat x lon x time:
%  sst = permute(sst,[2 1 3]); 
%  
%  % Save the sample data:
%  save('PacOcean.mat','lat','lon','t','sst') 
% 
%% References 
% 
% Messié, Monique, and Francisco Chavez. "Global modes of sea surface temperature variability in relation to regional 
% climate indices." Journal of Climate 24.16 (2011): 4314-4331. <http://dx.doi.org/10.1175/2011JCLI3941.1 doi:10.1175/2011JCLI3941.1>.
%
% Rayner, N. A., Parker, D. E., Horton, E. B., Folland, C. K., Alexander, L. V., Rowell, D. P., Kent, E. C., Kaplan, A.  
% (2003). Global analyses of sea surface temperature, sea ice, and night marine air temperature since the late nineteenth century. 
% J. Geophys. Res.Vol. 108, No. D14, 4407 <http://dx.doi.org/10.1029/2002JD002670 doi:10.1029/2002JD002670>.
% 
% Thyng, K.M., C.A. Greene, R.D. Hetland, H.M. Zimmerle, and S.F. DiMarco. 2016. True colors of oceanography: Guidelines for
% effective and accurate colormap selection. Oceanography 29(3):9-13, <http://dx.doi.org/10.5670/oceanog.2016.66 doi:10.5670/oceanog.2016.66>.
% 
%% Author Info 
% The |eof| function was written by <http://www.chadagreene.com Chad A. Greene> of the University of Texas 
% Institute for Geophysics (UTIG) in January 2017, but leans heavily on Guillame MAZE's |caleof| function
% from his <https://www.mathworks.com/matlabcentral/fileexchange/17915 PCATool> contribution. This tutorial
% was written by Chad Greene with help from <https://www.kaustubh.info/ Kaustubh Thirumalai>. 
##### SOURCE END #####
--></body></html>