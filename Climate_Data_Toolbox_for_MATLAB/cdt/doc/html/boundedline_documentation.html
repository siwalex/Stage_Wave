
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>boundedline documentation</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-01-18"><meta name="DC.source" content="boundedline_documentation.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1><tt>boundedline</tt> documentation</h1><!--introduction--><p>The <tt>boundedline</tt> function plots lines with shaded error/confidence bounds.</p><p><a href="CDT_Contents.html">Back to Climate Data Tools Contents</a></p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">Example 1: Plotting lines using various syntax options</a></li><li><a href="#7">Example 2: Common climate data uses</a></li><li><a href="#10">Example 3: Filling gaps</a></li><li><a href="#15">Author Info</a></li></ul></div><h2 id="1">Syntax</h2><pre>boundedline(x, y, b)
boundedline(x, y, b, linespec)
boundedline(x1, y1, b1, linespec1,  x2, y2, b2, linespec2)
boundedline(..., 'alpha')
boundedline(..., ax)
boundedline(..., 'transparency', trans)
boundedline(..., 'orientation', orient)
boundedline(..., 'nan', nanflag)
boundedline(..., 'cmap', cmap)
[hl, hp] = boundedline(...)</pre><h2 id="2">Description</h2><p><tt>boundedline(x, y, b)</tt> plots a line with coordinates given by <tt>x</tt> and <tt>y</tt>, surrounded by a patch extending a certain distance <tt>b</tt> above/below that line.  The dimensions of the <tt>x</tt>, <tt>y</tt>, and <tt>b</tt> arrays can vary to allow for multiple lines to be plotted at once, and for patch bounds to be either constant or varying along the length of the line.  The dimensions of <tt>x</tt> and <tt>y</tt> must meet the same requirements as for the <tt>plot</tt> function, and will produce the same number of lines as produced by <tt>plot</tt> with the same inputs.  The <tt>b</tt> array should be a npoint x nside x nline array, with dimensions corresponding to each point along the line (dimension 1), each side of the line (lower/upper or left/right, depending on orientation) (dimension 2), and each plotted line described by the preceding x-y values (dimension 3).  If size(b,1) == 1, the bounds will be the same for all points along the line.  If size(b,2) == 1, the bounds will be symmetrical on both sides of the lines.  If size(b,3) == 1, the same bounds will be applied to all lines described by the preceding x-y arrays (only applicable when either x or y is an array).  Bounds cannot include Inf, -Inf, or NaN.</p><p><tt>boundedline(..., 'alpha')</tt> renders the bounded area patch using a partially-transparent patch the same color as the corresponding line(s). If not included, the bounded area will use a fully-opaque patch in a lighter shade of the corresponding line color.</p><p><tt>boundedline(..., 'transparency', transp)</tt> indicates the tranparency or intensity of the bounds patch, using a scalar between 0 and 1.  Default is 0.2.</p><p><tt>boundedline(..., 'orientation', orient)</tt> indicates the orientation of the bounds.  Orientation can be either <tt>'vert'</tt> for vertical (y-direction) bounds, or <tt>'horiz'</tt> for horizontal (x-direction) bounds.  Default is <tt>'vert'</tt>.</p><p><tt>boundedline(..., 'nan', nanflag)</tt> indicates how the bounds patch should handle NaNs in the line coordinates or bounds values.  Options are <tt>'fill'</tt>, to smooth over the gap using neighboring values, <tt>'gap'</tt> to leave a blank space in the patch at those points, or <tt>'remove'</tt> to drop the NaN-points entirely, leading to linear interpolation of the gap in the patch.  See examples below for more details on these options.</p><p><tt>boundedline(..., 'color', col)</tt> specifies a line color.</p><p><tt>boundedline(..., 'cmap', cmap)</tt> colors the lines (in order of plotting) acording to the colors in this n x 3 colormap array, overriding any linespec or default colors.</p><p><tt>boundedline(..., ax)</tt> plots the bounded line to the axis indicated by handle <tt>ax</tt>.  If not included, the current axis is used.</p><p><tt>[hl, hp] = boundedline(...)</tt> returns the handles the resulting line and patch object(s) to <tt>hl</tt> and <tt>hp</tt>, respectively.</p><h2 id="3">Example 1: Plotting lines using various syntax options</h2><p>This example builds the 4-panel example image used on the MatlabCentral File Exchange, which shows several different methods for supplying line coordinates, bounds coordinates, and shading options.</p><p>The first axis plots two lines using the LineSpec option for input, which allows yoy to set line color, line color, and marker type for each line. The bounds on the first line vary over x, while the bounds on the second line are constant for all x. An outline is added to the bounds so the overlapping region can be seen more clearly.</p><pre class="codeinput">x = linspace(0, 2*pi, 50);
y1 = sin(x);
y2 = cos(x);
e1 = rand(size(y1))*.5+.5;
e2 = [.25 .5];

ax(1) = subplot(2,2,1);
[l,p] = boundedline(x, y1, e1, <span class="string">'-b*'</span>, x, y2, e2, <span class="string">'--ro'</span>);
outlinebounds(l,p);
title(<span class="string">'Opaque bounds, with outline'</span>);
axis <span class="string">tight</span>;
</pre><img vspace="5" hspace="5" src="boundedline_documentation_01.png" alt=""> <p>For our second axis, we use the same 2 lines, and this time assign x-varying bounds to both lines.  Rather than using the LineSpec syntax, this  example uses the default color order to assign the colors of the lines and patches.  I also turn on the <tt>'alpha'</tt> option, which renders the patch wit partial transparency.</p><pre class="codeinput">ax(2) = subplot(2,2,2);
boundedline(x, [y1;y2], rand(length(y1),2,2)*.5+.5, <span class="string">'alpha'</span>);
title(<span class="string">'Transparent bounds'</span>);
axis <span class="string">tight</span>;
</pre><img vspace="5" hspace="5" src="boundedline_documentation_02.png" alt=""> <p>The bounds can also be assigned to a horizontal orientation, for a case where the x-axis represents the dependent variable.  In this case, the scalar error bound value applies to both lines and both sides of the lines.</p><pre class="codeinput">ax(3) = subplot(2,2,3);
boundedline([y1;y2], x, e1(1), <span class="string">'orientation'</span>, <span class="string">'horiz'</span>)
title(<span class="string">'Horizontal bounds'</span>);
axis <span class="string">tight</span>;
</pre><img vspace="5" hspace="5" src="boundedline_documentation_03.png" alt=""> <p>Rather than use a LineSpec or the default color order, a colormap array can be used to assign colors.  In this case, increasingly-narrower bounds are added on top of the same line.</p><pre class="codeinput">ax(4) = subplot(2,2,4);
boundedline(x, repmat(y1, 4,1), permute(0.5:-0.1:0.2, [3 1 2]), <span class="keyword">...</span>
    <span class="string">'cmap'</span>, cool(4), <span class="keyword">...</span>
    <span class="string">'transparency'</span>, 0.5);
title(<span class="string">'Multiple bounds using colormap'</span>);

set(ax([1 2 4]), <span class="string">'xlim'</span>, [0 2*pi]);
set(ax(3), <span class="string">'ylim'</span>, [0 2*pi]);
axis <span class="string">tight</span>;
</pre><img vspace="5" hspace="5" src="boundedline_documentation_04.png" alt=""> <h2 id="7">Example 2: Common climate data uses</h2><p>A typical use of this type of plot would be to show a range in values associated with a timeseries.  For example, let's looks at the seasonal variation in sea ice extent data:</p><pre class="codeinput">S = load(<span class="string">'seaice_extent.mat'</span>);
figure;
plot(doy(S.t), S.extent_N, <span class="string">'.'</span>);
set(gca, <span class="string">'xlim'</span>, [0 366]);
</pre><img vspace="5" hspace="5" src="boundedline_documentation_05.png" alt=""> <p>We can calculate the daily range across all years, and plot these bounds along with the mean</p><pre class="codeinput">[g, dy] = findgroups(doy(S.t));
icemin = splitapply(@min, S.extent_N, g);
icemax = splitapply(@max, S.extent_N, g);
icemean = splitapply(@mean, S.extent_N, g);
bnd = [icemean - icemin, icemax - icemean];

cla;
boundedline(dy, icemean, bnd);
</pre><img vspace="5" hspace="5" src="boundedline_documentation_06.png" alt=""> <p>One thing to note when plotting timeseries is that patch objects do not currently support datetime input, and therefore neither can boundedline at this time; you must first convert datetime input data to datenumbers to plot with this function, and cannot target a datetime axis.</p><h2 id="10">Example 3: Filling gaps</h2><p>If you plot a line with one or more NaNs in either the <tt>x</tt> or <tt>y</tt> vector, the NaN location is rendered as a missing marker with a gap in the line. However, the <tt>patch</tt> command does not handle NaNs gracefully; it simply fails to show the patch at all if any of the coordinates include NaNs.</p><p>Because of this, the expected behavior of the patch part of boundedline when confronted with a NaN in either the bounds array (<tt>b</tt>) or the x/y-coordinates of the line (which are used to calculate the patch coordinates) is ambiguous.  I offer a few options.</p><p>Before I demonstrate the options, I'll create a dataset that has a few different types of gaps:</p><pre class="codeinput">x = linspace(0, 2*pi, 50);
y = sin(x);
b = [ones(size(y))*0.2; rand(size(y))*.5+.5]';

y(10)   = NaN;  <span class="comment">% NaN in the line but not bounds</span>
b(20,1) = NaN;  <span class="comment">% NaN in lower bound but not line</span>
b(30,2) = NaN;  <span class="comment">% NaN in upper bound but not line</span>
b(40,:) = NaN;  <span class="comment">% NaN in both sides of bound but not line</span>
</pre><p>Here's what that looks like in an errorbar plot.</p><pre class="codeinput">figure;
he = errorbar(x,y,b(:,1), b(:,2), <span class="string">'-bo'</span>);


line([x([10 20 30 40]); x([10 20 30 40])], [ones(1,4)*-2;ones(1,4)*2], <span class="keyword">...</span>
    <span class="string">'color'</span>, ones(1,3)*0.5, <span class="string">'linestyle'</span>, <span class="string">':'</span>);
text(x(10), sin(x(10))-0.2, {<span class="string">'\uparrow'</span>,<span class="string">'Line'</span>,<span class="string">'gap'</span>}, <span class="string">'vert'</span>, <span class="string">'top'</span>, <span class="string">'horiz'</span>, <span class="string">'center'</span>);
text(x(20), sin(x(20))-0.2, {<span class="string">'\uparrow'</span>,<span class="string">'Lower'</span>,<span class="string">'bound'</span>,<span class="string">'gap'</span>}, <span class="string">'vert'</span>, <span class="string">'top'</span>, <span class="string">'horiz'</span>, <span class="string">'center'</span>);
text(x(30), sin(x(30))-0.2, {<span class="string">'\uparrow'</span>,<span class="string">'Upper'</span>,<span class="string">'bound'</span>,<span class="string">'gap'</span>}, <span class="string">'vert'</span>, <span class="string">'top'</span>, <span class="string">'horiz'</span>, <span class="string">'center'</span>);
text(x(40), sin(x(40))-0.2, {<span class="string">'\uparrow'</span>,<span class="string">'Two-sided'</span>,<span class="string">'bound'</span>,<span class="string">'gap'</span>}, <span class="string">'vert'</span>, <span class="string">'top'</span>, <span class="string">'horiz'</span>, <span class="string">'center'</span>);

axis <span class="string">tight</span> <span class="string">equal</span>;
</pre><img vspace="5" hspace="5" src="boundedline_documentation_07.png" alt=""> <p>The default method for dealing with NaNs in boundedline is to leave the gap in the line, but smooth over the gap in the bounds based on the neighboring points.  This option can be nice if you only have one or two missing points, and you're not interested in emphasizing those gaps in your plot:</p><pre class="codeinput">delete(he);
[hl,hp] = boundedline(x,y,b,<span class="string">'-bo'</span>, <span class="string">'nan'</span>, <span class="string">'fill'</span>);
ho = outlinebounds(hl,hp);
set(ho, <span class="string">'linestyle'</span>, <span class="string">':'</span>, <span class="string">'color'</span>, <span class="string">'r'</span>, <span class="string">'marker'</span>, <span class="string">'.'</span>);
</pre><img vspace="5" hspace="5" src="boundedline_documentation_08.png" alt=""> <p>I've added bounds outlines in a contrasting color so you can see how I'm handling individual points.</p><p>The second option leaves a full gap in the patch for any NaN.  I considered allowing one-sided gaps, but couldn't think of a good way to distinguish a gap from a zero-valued bound.  I'm open to suggestions if you have any (email me).</p><pre class="codeinput">delete([hl hp ho]);
[hl,hp] = boundedline(x,y,b,<span class="string">'-bo'</span>, <span class="string">'nan'</span>, <span class="string">'gap'</span>);
ho = outlinebounds(hl,hp);
set(ho, <span class="string">'linestyle'</span>, <span class="string">':'</span>, <span class="string">'color'</span>, <span class="string">'r'</span>, <span class="string">'marker'</span>, <span class="string">'.'</span>);
</pre><img vspace="5" hspace="5" src="boundedline_documentation_09.png" alt=""> <p>The final option removes points from the patch that are NaNs.  The visual result is very similar to the fill option, but the missing points are apparent if you plot the bounds outlines.</p><pre class="codeinput">delete([hl hp ho]);
[hl,hp] = boundedline(x,y,b,<span class="string">'-bo'</span>, <span class="string">'nan'</span>, <span class="string">'remove'</span>);
ho = outlinebounds(hl,hp);
set(ho, <span class="string">'linestyle'</span>, <span class="string">':'</span>, <span class="string">'color'</span>, <span class="string">'r'</span>, <span class="string">'marker'</span>, <span class="string">'.'</span>);
</pre><img vspace="5" hspace="5" src="boundedline_documentation_10.png" alt=""> <h2 id="15">Author Info</h2><p>This function and supporting documentation was written by Kelly Kearney for the Climate Data Toolbox for Matlab, 2019.  It is available as part of this toolbox, and can also be downloaded individually from <a href="https://github.com/kakearney/boundedline-pkg">GitHub</a>.</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% |boundedline| documentation 
% The |boundedline| function plots lines with shaded error/confidence
% bounds.
% 
% <CDT_Contents.html Back to Climate Data Tools Contents>
%
%% Syntax
%
%  boundedline(x, y, b)
%  boundedline(x, y, b, linespec)
%  boundedline(x1, y1, b1, linespec1,  x2, y2, b2, linespec2)
%  boundedline(..., 'alpha')
%  boundedline(..., ax)
%  boundedline(..., 'transparency', trans)
%  boundedline(..., 'orientation', orient)
%  boundedline(..., 'nan', nanflag)
%  boundedline(..., 'cmap', cmap)
%  [hl, hp] = boundedline(...)
%
%% Description
%
% |boundedline(x, y, b)| plots a line with coordinates given by
% |x| and |y|, surrounded by a patch extending a certain distance |b|
% above/below that line.  The dimensions of the |x|, |y|, and |b| arrays
% can vary to allow for multiple lines to be plotted at once, and for
% patch bounds to be either constant or varying along the length of the
% line.  The dimensions of |x| and |y| must meet the same requirements as
% for the |plot| function, and will produce the same number of lines as
% produced by |plot| with the same inputs.  The |b| array should be a
% npoint x nside x nline array, with dimensions corresponding to each point
% along the line (dimension 1), each side of the line (lower/upper or
% left/right, depending on orientation) (dimension 2), and each plotted
% line described by the preceding x-y values (dimension 3).  If size(b,1)
% == 1, the bounds will be the same for all points along the line.  If
% size(b,2) == 1, the bounds will be symmetrical on both sides of the
% lines.  If size(b,3) == 1, the same bounds will be applied to all lines
% described by the preceding x-y arrays (only applicable when either x or y
% is an array).  Bounds cannot include Inf, -Inf, or NaN.
%  
% |boundedline(..., 'alpha')| renders the bounded area patch using a
% partially-transparent patch the same color as the corresponding line(s).
% If not included, the bounded area will use a fully-opaque patch in a
% lighter shade of the corresponding line color.
%
% |boundedline(..., 'transparency', transp)| indicates the
% tranparency or intensity of the bounds patch, using a scalar between 0
% and 1.  Default is 0.2.
%
% |boundedline(..., 'orientation', orient)| indicates the orientation of
% the bounds.  Orientation can be either |'vert'| for vertical (y-direction)
% bounds, or |'horiz'| for horizontal (x-direction) bounds.  Default is
% |'vert'|.
%
% |boundedline(..., 'nan', nanflag)| indicates how the bounds patch should
% handle NaNs in the line coordinates or bounds values.  Options are
% |'fill'|, to smooth over the gap using neighboring values, |'gap'| to
% leave a blank space in the patch at those points, or |'remove'| to drop
% the NaN-points entirely, leading to linear interpolation of the gap in
% the patch.  See examples below for more details on these options.
%
% |boundedline(..., 'color', col)| specifies a line color. 
%
% |boundedline(..., 'cmap', cmap)| colors the lines (in order of plotting)
% acording to the colors in this n x 3 colormap array, overriding any
% linespec or default colors.
%
% |boundedline(..., ax)| plots the bounded line to the axis indicated by
% handle |ax|.  If not included, the current axis is used.
%
% |[hl, hp] = boundedline(...)| returns the handles the resulting line
% and patch object(s) to |hl| and |hp|, respectively.
%
%% Example 1: Plotting lines using various syntax options
%
% This example builds the 4-panel example image used on the MatlabCentral
% File Exchange, which shows several different methods for supplying line
% coordinates, bounds coordinates, and shading options.
%
% The first axis plots two lines using the LineSpec option for input, which
% allows yoy to set line color, line color, and marker type for each line.
% The bounds on the first line vary over x, while the bounds on the second
% line are constant for all x. An outline is added to the bounds so the
% overlapping region can be seen more clearly. 

x = linspace(0, 2*pi, 50);
y1 = sin(x);
y2 = cos(x);
e1 = rand(size(y1))*.5+.5;
e2 = [.25 .5];

ax(1) = subplot(2,2,1);
[l,p] = boundedline(x, y1, e1, '-b*', x, y2, e2, 'REPLACE_WITH_DASH_DASHro');
outlinebounds(l,p);
title('Opaque bounds, with outline');
axis tight;

%%
% For our second axis, we use the same 2 lines, and this time assign
% x-varying bounds to both lines.  Rather than using the LineSpec syntax,
% this  example uses the default color order to assign the colors of the
% lines and patches.  I also turn on the |'alpha'| option, which renders
% the patch wit partial transparency.

ax(2) = subplot(2,2,2);
boundedline(x, [y1;y2], rand(length(y1),2,2)*.5+.5, 'alpha');
title('Transparent bounds');
axis tight;

%%
% The bounds can also be assigned to a horizontal orientation, for a case
% where the x-axis represents the dependent variable.  In this case, the
% scalar error bound value applies to both lines and both sides of the
% lines.

ax(3) = subplot(2,2,3);
boundedline([y1;y2], x, e1(1), 'orientation', 'horiz')
title('Horizontal bounds');
axis tight;

%%
% Rather than use a LineSpec or the default color order, a colormap array
% can be used to assign colors.  In this case, increasingly-narrower bounds
% are added on top of the same line.

ax(4) = subplot(2,2,4);
boundedline(x, repmat(y1, 4,1), permute(0.5:-0.1:0.2, [3 1 2]), ...
    'cmap', cool(4), ...
    'transparency', 0.5);
title('Multiple bounds using colormap');

set(ax([1 2 4]), 'xlim', [0 2*pi]);
set(ax(3), 'ylim', [0 2*pi]);
axis tight;

%% Example 2: Common climate data uses
%
% A typical use of this type of plot would be to show a range in values
% associated with a timeseries.  For example, let's looks at the seasonal
% variation in sea ice extent data:

S = load('seaice_extent.mat');
figure;
plot(doy(S.t), S.extent_N, '.');
set(gca, 'xlim', [0 366]);

%%
% We can calculate the daily range across all years, and plot these bounds
% along with the mean

[g, dy] = findgroups(doy(S.t));
icemin = splitapply(@min, S.extent_N, g);
icemax = splitapply(@max, S.extent_N, g);
icemean = splitapply(@mean, S.extent_N, g);
bnd = [icemean - icemin, icemax - icemean];

cla;
boundedline(dy, icemean, bnd);

%%
% One thing to note when plotting timeseries is that patch objects do not
% currently support datetime input, and therefore neither can boundedline
% at this time; you must first convert datetime input data to datenumbers
% to plot with this function, and cannot target a datetime axis.


%% Example 3: Filling gaps
%
% If you plot a line with one or more NaNs in either the |x| or |y| vector,
% the NaN location is rendered as a missing marker with a gap in the line.
% However, the |patch| command does not handle NaNs gracefully; it simply
% fails to show the patch at all if any of the coordinates include NaNs.
%
% Because of this, the expected behavior of the patch part of boundedline
% when confronted with a NaN in either the bounds array (|b|) or the
% x/y-coordinates of the line (which are used to calculate the patch
% coordinates) is ambiguous.  I offer a few options.  
%
% Before I demonstrate the options, I'll create a dataset that has a few
% different types of gaps:

x = linspace(0, 2*pi, 50);
y = sin(x);
b = [ones(size(y))*0.2; rand(size(y))*.5+.5]';

y(10)   = NaN;  % NaN in the line but not bounds
b(20,1) = NaN;  % NaN in lower bound but not line
b(30,2) = NaN;  % NaN in upper bound but not line
b(40,:) = NaN;  % NaN in both sides of bound but not line

%%
% Here's what that looks like in an errorbar plot.

figure;
he = errorbar(x,y,b(:,1), b(:,2), '-bo');


line([x([10 20 30 40]); x([10 20 30 40])], [ones(1,4)*-2;ones(1,4)*2], ...
    'color', ones(1,3)*0.5, 'linestyle', ':');
text(x(10), sin(x(10))-0.2, {'\uparrow','Line','gap'}, 'vert', 'top', 'horiz', 'center');
text(x(20), sin(x(20))-0.2, {'\uparrow','Lower','bound','gap'}, 'vert', 'top', 'horiz', 'center');
text(x(30), sin(x(30))-0.2, {'\uparrow','Upper','bound','gap'}, 'vert', 'top', 'horiz', 'center');
text(x(40), sin(x(40))-0.2, {'\uparrow','Two-sided','bound','gap'}, 'vert', 'top', 'horiz', 'center');

axis tight equal;

%% 
% The default method for dealing with NaNs in boundedline is to leave the
% gap in the line, but smooth over the gap in the bounds based on the
% neighboring points.  This option can be nice if you only have one or two
% missing points, and you're not interested in emphasizing those gaps in
% your plot:

delete(he);
[hl,hp] = boundedline(x,y,b,'-bo', 'nan', 'fill');
ho = outlinebounds(hl,hp);
set(ho, 'linestyle', ':', 'color', 'r', 'marker', '.');

%%
% I've added bounds outlines in a contrasting color so you can see how I'm
% handling individual points.
%
% The second option leaves a full gap in the patch for any NaN.  I
% considered allowing one-sided gaps, but couldn't think of a good way to
% distinguish a gap from a zero-valued bound.  I'm open to suggestions if
% you have any (email me).

delete([hl hp ho]);
[hl,hp] = boundedline(x,y,b,'-bo', 'nan', 'gap');
ho = outlinebounds(hl,hp);
set(ho, 'linestyle', ':', 'color', 'r', 'marker', '.');

%%
% The final option removes points from the patch that are NaNs.  The visual
% result is very similar to the fill option, but the missing points are
% apparent if you plot the bounds outlines.

delete([hl hp ho]);
[hl,hp] = boundedline(x,y,b,'-bo', 'nan', 'remove');
ho = outlinebounds(hl,hp);
set(ho, 'linestyle', ':', 'color', 'r', 'marker', '.');

%% Author Info
%
% This function and supporting documentation was written by Kelly Kearney
% for the Climate Data Toolbox for Matlab, 2019.  It is available as part
% of this toolbox, and can also be downloaded individually from
% <https://github.com/kakearney/boundedline-pkg GitHub>.



##### SOURCE END #####
--></body></html>